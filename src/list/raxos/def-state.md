
# 分布式一致性的事件历史

在分布式系统中，一致性协议的核心目标是确保对系统**状态**达成共识。我们可以这样理解：系统的状态（State）可以被视为一系列有序的、对系统状态进行变更的**事件**(**Event**) 的结果。 也就是说，任何给定的系统状态都可以通过一组特定的有序 **Event** 来唯一确定。

当一个 **Event** 被引入系统时，它会与所有已存在的, 且存在依赖关系的 **Event** 建立有向边。这些有向边明确地表示了 **Event** 的发生顺序。我们将这组有序的 **Event** 集合称为系统Event的**历史**( **History** )。**History** 的定义确保了其无环性，即一个 **Event** 不可能依赖于它自身或其后续 **Event**，从而保证了 **Event** 发生的逻辑顺序。

基于以上定义，系统的状态可以被表示为 **Event** 的一个有向无环图：

```rust
type State = DAG<Event>;
```

例如: 考虑以下一系列 **Event**, 下面这个存储系统初始状态是 `⊥`, 先并发的加入了E1和E2, 它们之间没有依赖关系,
然后先后又加入的E3,同时依赖E1和E2, 然后又加入了E4,依赖E3:

![](history.excalidraw.png)

其中

```text
E1: let x = 1;
E2: let y = 2;
E3: let x = x + y;
E4: let z = 5;
E5: let w = 6;
```

那么系统的状态可以被计算为：

```
State = apply(History)
      = apply((E1, E2)->E3->(E4, E5))
      = { x = 3; y = 2; w = 6; z = 5}
```

其中，`apply` 函数是一个确定性的函数，它将 **History** 解释为系统的状态。该函数按照 **History** 中 **Event** 的偏序顺序执行，并产生最终的系统状态。通过以上定义，我们可以将分布式系统中一致性问题转化为对 **Event History** 达成共识的问题。

注意Event之间的依赖关系是业务定义的, 例如Event `let x = x + y` 可以定义它必须依赖`let x = 2`, 也可以不依赖, 它将导致最终的系统状态的不同, 但对于描述分布式一致性算法没有影响. 