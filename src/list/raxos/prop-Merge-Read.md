## 合并读结果


read 返回的结果做并集作为返回的结果, 但是这里有些 History 是不能合并的:

这是因为分布式中的 read 可以选择不同的节点来读, 可能每次读到的结果不同.
假设系统中的时间是`pT1 < pT2 < pT6; pT1 < pT3 < pT6`:

`read(pT6, {1,3})` 得到 `[{E1}, {E1->E3}]`, 这 2 个 History 是可以合并的, 得到 `{E1->E3}`.
`read(pT6, {2,3})` 得到 `[{E1}, {E1->E2}]`, 这 2 个 History 是可以合并的, 得到 `{E1->E2}`.

`read(pT6, {1,2})` 得到 `[{E1->E2}, {E1->E3}]`, 这时, 如果 E2 和 E3 的时间 pT2 和 pT3 不可比较,
那么这次读取可以合并结果为`{E1->(E2,E3)}`;
但如果`pT2 < pT3`, 假设合并为`{E1->E2->E3}`, 会造成 E3 这个事件的历史发生变化, 合并之后就不再是之前的时间和 Event 了. 因此不能合并.


![](history-conflict.excalidraw.png)

所以规则是:
合并之后的图的边集合和合并前的图的边集的并集相同.
或者说, 合并后不能产生新的边.
或者说, 对 2 个 History A 和 B, 只在 A 中的节点和只在 B 中的节点没有大小关系.

这是因为, 如果有新的边出现, 意味着会产生读到历史被改变了.

所以必须舍弃其中一个